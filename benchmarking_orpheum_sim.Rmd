---
title: "Orpheum on simulated reads"
author: "Taylor Reiter"
date:  '`r format(Sys.Date(), "%B %d, %Y")`'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message = F, include = T, eval = T, warning = F,
                      cache = T)
options(scipen=999)
```

```{r libraries}
library(dplyr)
library(readr)
library(tibble)
library(tidyr)
library(ggplot2)
library(ggpmisc)
library(ggpubr)
library(broom)
library(kableExtra)
library(rjson)
library(purrr)
library(janitor)
```

```{r ggplot_base}
ggplot_base <- theme_minimal() +
  theme(plot.title = element_text(size = 8),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 7),
        legend.title = element_text(size = 6), 
        legend.text = element_text(size = 6),
        plot.title.position = "plot")
```

```{r function_read_and_format_orpheum_json}
read_and_format_orpheum_json <- function(sys_glob_path, database, alphabet, ksize) {
  file_prefix = paste0("outputs\\/orpheum\\/", database, "\\/", alphabet, "-k", ksize, "\\/")
  json_df <- Sys.glob(sys_glob_path) %>%
    set_names() %>%
    map_dfr(~RJSONIO::fromJSON(content =., nullValue = NaN)$categorization_counts, .id = "sample") %>%
    clean_names() %>%
    mutate(sample = gsub(file_prefix, "", sample)) %>%
    mutate(sample = gsub(".summary\\.json", "", sample)) %>%
    mutate(database = database) %>%
    mutate(ksize = paste0("k=", ksize)) %>%
    mutate(alphabet = alphabet) %>%
    mutate(total_reads = rowSums(across(where(is.numeric))))
     
  return(json_df)
}

read_and_format_orpheum_json_translation <- function(sys_glob_path, database, alphabet, ksize) {
  file_prefix = paste0("outputs\\/orpheum\\/", database, "\\/", alphabet, "-k", ksize, "\\/")
  json_df <- Sys.glob(sys_glob_path) %>%
    set_names() %>%
    map_dfr(~RJSONIO::fromJSON(content =., nullValue = NaN)$histogram_n_coding_frames_per_read, .id = "sample") %>%
    clean_names() %>%
    mutate(sample = gsub(file_prefix, "", sample)) %>%
    mutate(sample = gsub("\\.summary\\.json", "", sample)) %>%
    mutate(database = database) %>%
    mutate(ksize = paste0("k=", ksize)) %>%
    mutate(alphabet = alphabet)
  
  # make sure numbers are encoded as numeric, then replace NAs with 0s and sum to coding
  json_df <- json_df %>%
    mutate(across(where(~ anyNA(.) & is.numeric(.)), ~ replace_na(., 0))) %>%
    mutate(coding_reads = rowSums(across(where(is.numeric))))
  
  # add missing cols
  columns <- c(number_of_reads_with_1_putative_protein_coding_translations = 0,
               number_of_reads_with_2_putative_protein_coding_translations = 0,
               number_of_reads_with_3_putative_protein_coding_translations = 0,
               number_of_reads_with_4_putative_protein_coding_translations = 0,
               number_of_reads_with_5_putative_protein_coding_translations = 0,
               number_of_reads_with_6_putative_protein_coding_translations = 0)
  json_df <- json_df %>%
    add_column(!!!columns[!names(columns) %in% names(.)])
  
  # calculate percentage of reads translated into n number of coding frames
  json_df <- json_df %>%
    mutate(f_putative_coding_1_translation = ifelse(number_of_reads_with_1_putative_protein_coding_translations == 0, 0,
                                                    number_of_reads_with_1_putative_protein_coding_translations/coding_reads)) %>%
    mutate(f_putative_coding_2_translation = ifelse(number_of_reads_with_2_putative_protein_coding_translations == 0, 0,
                                                    number_of_reads_with_2_putative_protein_coding_translations/coding_reads)) %>%
    mutate(f_putative_coding_3_translation = ifelse(number_of_reads_with_3_putative_protein_coding_translations == 0, 0,
                                                    number_of_reads_with_3_putative_protein_coding_translations/coding_reads)) %>%
    mutate(f_putative_coding_4_translation = ifelse(number_of_reads_with_4_putative_protein_coding_translations == 0, 0,
                                                    number_of_reads_with_4_putative_protein_coding_translations/coding_reads)) %>%
    mutate(f_putative_coding_5_translation = ifelse(number_of_reads_with_5_putative_protein_coding_translations == 0, 0,
                                                    number_of_reads_with_5_putative_protein_coding_translations/coding_reads)) %>%
    mutate(f_putative_coding_6_translation = ifelse(number_of_reads_with_6_putative_protein_coding_translations == 0, 0,
                                                    number_of_reads_with_6_putative_protein_coding_translations/coding_reads))
  
  return(json_df)
}
```

```{r function_plot_orpheum}
plot_orpheum_translation_frames <- function(orpheum_trans, ksize, alphabet, database){
  orpheum_trans_long <- orpheum_trans %>%
    select(sample, database, ksize, alphabet, starts_with("f_putative")) %>%
    pivot_longer(cols = starts_with("f_putative"), names_to = "translation_frame", values_to = "fraction") %>%
    mutate(translation_frame = gsub("f_putative_coding_", "", translation_frame)) %>%
    mutate(translation_frame = gsub("_translation", "", translation_frame))
  
  ggplot(orpheum_trans_long, aes(x = translation_frame, y = fraction)) +
    geom_violin(scale = "width") +
    theme_minimal() +
    ggplot_base +
    # geom_segment(aes(x = .5, y = .91, xend = 1.5, yend = .91), linetype = "dashed") +
    # geom_segment(aes(x = .5, y = .99, xend = 1.5, yend = .99), linetype = "dashed") +
    # geom_segment(aes(x = 1.5, y = .09, xend = 2.5, yend = .09), linetype = "dashed") +
    # geom_segment(aes(x = 1.5, y = .01, xend = 2.5, yend = .01), linetype = "dashed") +
    labs(x = "number of coding frames per read", y = "fraction of putative coding reads",
         title = paste0("db = ", database, ", alphabet = ", alphabet, ", k = ", ksize))
}
```

## Background

+ The average bacterial genome is 5 Mbp and encodes 5000 proteins ([Land et al. 2015](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4361730/)). As of January 2014:
    + The largest bacterial genome in GenBank was *Sorangium cellulosum* strain So0157-2, with 14,782,125 bp encoding 11,599 genes
    + The smallest bacterial genome in GenBank was *Candidatus Nasuia deltocephalinicola* strain NAS-ALF with 112,091 bp encoding 137 genes.
+ It is estimated that 88% (40-97%) of the bacterial genome is protein coding ([Land et al. 2015](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4361730/)).
+ It is not currently known how many alternate/overlapping ORFs exist in a bacterial genome.
    + Computational estimates suggest there are 10-400 alternate ORFs per genome ([Ardern et al. 2020](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7457138/)).
    + Experimental evidence suggest ~100 alternate overlapping ORFs per genome ([Zehentner et al. 2020](https://www.biorxiv.org/content/10.1101/2020.11.18.388249v1.full.pdf))

## Results

```{r metadata}
info <- read_tsv("inputs/all_genomes_genbank_info_metadata.tsv") %>%
  mutate(accession_minus_prefix = gsub("[12]$", "", accession_minus_prefix)) %>%
  mutate(set = gsub("refseq_not_in_genbank", "refseq_not_in_gtdb", set))

refseq <- read_tsv("inputs/refseq_not_in_gtdb_metadata.tsv")
gtdb <- read_tsv("inputs/gtdb_metadata.tsv")

gtdbtk <- read_tsv("outputs/gtdbtk/gtdbtk.ar122.summary.tsv", col_types = "cccdcddcddddccccdc", na = "N/A")
gtdbtk <- read_tsv("outputs/gtdbtk/gtdbtk.bac120.summary.tsv", col_types = "cccdcddcddddccccdc", na = "N/A") %>%
  bind_rows(gtdbtk) %>%
  mutate(user_genome = gsub("_genomic", "", user_genome)) %>%
  mutate(accession_minus_prefix = gsub("GCA_", "", user_genome)) %>%
  mutate(accession_minus_prefix = gsub("\\.[1-9].*", "", accession_minus_prefix)) %>%
  separate(classification, into=c("superkingdom", "phylum", "order", "class", "family", "genus", "species"), sep = ";")
```

```{r gtdb_json_num}
json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/gtdb-rs202/protein-k10/*json",
                                     database = "gtdb-rs202", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")
```

```{r gtdb_json_translation}
translate <- read_and_format_orpheum_json_translation(sys_glob_path = "outputs/orpheum/gtdb-rs202/protein-k10/*json",
                                     database = "gtdb-rs202", 
                                     alphabet = "protein",
                                     ksize = 10) %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")
```

```{r json_long}
json_long <- json %>%
  select(accession_minus_prefix, type, set, total_reads,
         translation_is_shorter_than_peptide_k_mer_size_1, 
         translation_frame_has_stop_codon_s, coding, non_coding, low_complexity_nucleotide,
         read_length_was_shorter_than_3_peptide_k_mer_size, low_complexity_peptide_in_protein20_alphabet) %>%
  pivot_longer(cols = translation_is_shorter_than_peptide_k_mer_size_1:low_complexity_peptide_in_protein20_alphabet, names_to = "measurement", values_to = "reads")
```

```{r json_long_pct}
json_long_pct <- json_long %>%
  mutate(pct = reads/total_reads * 100) 
```

```{r, fig.height=9, eval = F}
# ggplot(json_long, aes(x = reorder(accession_minus_prefix, total_reads), y = reads, fill = measurement)) +
#   geom_col() +
#   theme_minimal() +
#   theme(legend.position = "bottom") +
#   coord_flip() +
#   facet_wrap(~ type + set, scales = "free_y") +
#   scale_fill_brewer(palette = "Dark2") +
#   guides(fill = guide_legend(nrow = 4))
```

```{r, fig.height=7, eval = F}
# ggplot(json_long %>% filter(measurement %in% c("coding", "non_coding")), 
#        aes(x = reorder(accession_minus_prefix, total_reads), y = reads, fill = measurement)) +
#   geom_col() +
#   theme_minimal() +
#   coord_flip() +
#   facet_wrap(~ type + set, scales = "free_y") +
#   scale_fill_brewer(palette = "Dark2")
```

```{r, fig.height=9, eval = F}
# plot_order_cds <- json_long_pct %>%
#   select(accession_minus_prefix, type, measurement, pct) %>%
#   filter(measurement == "coding") %>%
#   filter(type == "cds") %>%
#   arrange(desc(pct)) %>%
#   mutate(plot_order = 1:42) %>%
#   select(accession_minus_prefix, plot_order)
# 
# json_long_pct <- json_long_pct %>%
#   left_join(plot_order_cds)
# 
# ggplot(json_long_pct, 
#        aes(x = reorder(accession_minus_prefix, plot_order), y = pct, label = round(pct, digits = 0), fill = measurement)) +
#   geom_col() +
#   theme_minimal() +
#   theme(legend.position = "bottom") +
#   geom_text(size = 3, position = position_stack(vjust = 0.5)) + 
#   coord_flip() +
#   facet_wrap(~ type + set, scales = "free_y") +
#   scale_fill_brewer(palette = "Dark2") +
#   guides(fill = guide_legend(nrow = 4))
```

```{r plot}
# fix plot order for desc % TP CDS
plot_order_cds <- json_long_pct %>%
  select(accession_minus_prefix, type, measurement, pct) %>%
  filter(measurement == "coding") %>%
  filter(type == "cds") %>%
  arrange(desc(pct)) %>%
  mutate(plot_order = 1:42) %>%
  select(accession_minus_prefix, plot_order)

json_long_pct <- json_long_pct %>%
  left_join(plot_order_cds) %>%
  left_join(gtdbtk)

# fix species labels for "s__" and "g__"
json_long_pct <- json_long_pct %>%
  mutate(species = ifelse(species == "s__", genus, species)) %>%
  mutate(species = ifelse(species == "g__", family, species))

# change category to "other" for measurements
json_long_pct <- json_long_pct %>%
  mutate(measurement2 = ifelse(measurement %in% c("coding", "non_coding"), measurement, "other")) %>%
  group_by(accession_minus_prefix, type, set, species, plot_order, measurement2) %>%
  summarize(pct2 = sum(pct))

cds_noncds_gtdb_nongtdb_plt <- ggplot(json_long_pct %>% mutate(species = gsub(".__", "", species)), 
       aes(x = reorder(species, plot_order), y = pct2, label = round(pct2, digits = 0), fill = measurement2)) +
  geom_col() +
  theme_minimal() +
  theme(legend.position = "right",
        axis.text = element_text(size = 6),
        axis.text.y = element_text(face = "italic"),
        axis.title = element_text(size = 7),
        legend.title = element_text(size = 7),
        legend.text = element_text(size = 6),
        strip.text = element_text(size = 7),
        panel.spacing = unit(.1, "lines")) +
  geom_text(size = 2, position = position_stack(vjust = 0.5)) + 
  coord_flip() +
  labs(x = "species", y = "percent of reads", fill = "read type") +
  facet_wrap(~ type + set, scales = "free_y", 
             labeller = as_labeller(c(cds = "Coding", noncds = "Non-coding", 
                                      gtdb_representatives = "Genome in GTDB",
                                      refseq_not_in_gtdb = "Genome not in GTDB"))) +
  scale_fill_brewer(palette = "Dark2", labels = c("Coding", "Non-coding", "Other")) +
  guides(fill = guide_legend(nrow = 4))
```

```{r}
json_long_pct %>% 
  group_by(set, type, measurement2) %>%
  summarize(mean = mean(pct2),
            sd = sd(pct2))
```

```{r, eval = F}
# gtdb_all <- read_csv("https://osf.io/p6z3w/download")
# gtdb_tally_phylum <- gtdb_all %>% 
#   group_by(phylum) %>%
#   tally()
# 
# gtdb_tally_genus <- gtdb_all %>% 
#   group_by(phylum, class, order, family, genus) %>%
#   tally()
# 
# gtdb_tally_species <- gtdb_all %>% 
#   group_by(phylum, class, order, family, genus, species) %>%
#   tally()
```

## RefSeq not in GTDB

Orpheum performs increasingly poorly with increasingly large relatedness between the query genome and the closest related genome in GTDB.
If there is a species-level representative in the database, orpheum performs pretty well. 

```{r}
json_long_pct_refseq <- json_long_pct %>%
  filter(set == "refseq_not_in_gtdb") %>%
  filter(measurement2 == "coding") %>%
  filter(type == "cds") 

json_long_pct_refseq  <- json_long_pct_refseq  %>%
  mutate(classification_level = ifelse(grepl("f__", species), "family",
                                       ifelse(grepl("g__", species), "genus", "species")))
refseq_gtdbtk_plt <- ggplot(json_long_pct_refseq , aes(x = classification_level, y = pct2, 
                                                       label = accession_minus_prefix,
                                                       color = classification_level)) +
  geom_boxplot() +
  geom_point() +
  theme_minimal() +
  ylim(c(0, 100)) +
  theme(legend.position = "none",
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 7),
        legend.title = element_text(size = 7),
        legend.text = element_text(size = 6)) +
  labs(x = "Classification level by GTDB-Tk", y = "percent CDS reads\npredicted as coding") +
  scale_color_manual(values = c("family" = "#33A02C", genus = "#B2DF8A", species = "#1F78B4"))
```

## Jaccard similarity cutoff

```{r}
cutoffs <- Sys.glob("outputs/orpheum_cutoffs/gtdb-rs202/protein-k10/*tsv") %>%
  map_dfr(read_tsv) 

cutoffs <- cutoffs %>%
  left_join(info, by = c("accession" = "assembly_accession")) %>%
  left_join(gtdbtk, by = c("accession" = "user_genome")) %>%
  mutate(closest_classification_level = 
           ifelse(genus == "g__", "family",
                  ifelse(species == "s__", "genus", "species"))) %>%
  mutate(closest_classification_level = ifelse(set == "gtdb_representatives", 
                                               "genome", 
                                               closest_classification_level))

cutoffs$closest_classification_level <- factor(cutoffs$closest_classification_level,
                                               levels = c("genome", 
                                                          "species",
                                                          "genus", 
                                                          "family"))
tmp <- cutoffs %>%
  group_by(jaccard_cutoff, closest_classification_level) %>%
  summarize(mean_sensitivity = mean(sensitivity),
            mean_specificity = mean(specificity), 
            mean_youden = mean(youden_index))
  
jaccard_tp_plt  <- ggplot(tmp, aes(x = 1-mean_specificity, y = mean_sensitivity, color = closest_classification_level)) +
  geom_point(alpha = .5) +
  xlim(0, 1) + ylim(0, 1) +
  facet_wrap(~closest_classification_level) + 
  labs(x = "1 - specificity", y = "1 - sensitivity",
       color = "Rank of closest\nrelative in GTDB") +
  theme_minimal() +
  theme(legend.position = "right",
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 7),
        strip.text = element_text(size = 7),
        legend.title = element_text(size = 7),
        legend.text = element_text(size = 6)) +
  scale_color_brewer(palette = "Paired") +
  guides(fill = guide_legend(nrow = 5))

tmp %>%
  group_by(closest_classification_level) %>%
  arrange(desc(mean_youden)) %>%
  slice(1)


```

## Lineage plots

```{r read_cbeij}
cbeij_gtdb <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/gtdb-rs202/protein-k10/GCA_002006445.1*json",
                                     database = "gtdb-rs202", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

cbeij_phylum <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/p__Firmicutes_A/protein-k10/GCA_002006445.1*json",
                                     database = "p__Firmicutes_A", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

cbeij_class <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/c__Clostridia/protein-k10/GCA_002006445.1*json",
                                     database = "c__Clostridia", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

cbeij_order <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/o__Clostridiales/protein-k10/GCA_002006445.1*json",
                                     database = "o__Clostridiales", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

cbeij_family <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/f__Clostridiaceae/protein-k10/GCA_002006445.1*json",
                                     database = "f__Clostridiaceae", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

cbeij_genus <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/g__Clostridium/protein-k10/GCA_002006445.1*json",
                                     database = "g__Clostridium", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

cbeij_species <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/s__Clostridium_beijerincki/protein-k10/GCA_002006445.1*json",
                                     database = "s__Clostridium_beijerincki", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")


cbeij <- bind_rows(cbeij_species, cbeij_genus, cbeij_family, cbeij_order,
                   cbeij_class, cbeij_phylum, cbeij_gtdb)
```

```{r reformat_cbeij}
cbeij_long_pct <- cbeij %>%
  select(accession_minus_prefix, type, set, database, total_reads,
         translation_is_shorter_than_peptide_k_mer_size_1, 
         translation_frame_has_stop_codon_s, coding, non_coding, low_complexity_nucleotide,
         read_length_was_shorter_than_3_peptide_k_mer_size, low_complexity_peptide_in_protein20_alphabet) %>%
  pivot_longer(cols = translation_is_shorter_than_peptide_k_mer_size_1:low_complexity_peptide_in_protein20_alphabet, names_to = "measurement", values_to = "reads") %>%
  mutate(pct = reads/total_reads * 100) 

cbeij_long_pct <- cbeij_long_pct %>%
   left_join(gtdbtk)
```

```{r}

# change category to "other" for measurements
cbeij_long_pct <- cbeij_long_pct %>%
  mutate(measurement2 = ifelse(measurement %in% c("coding", "non_coding"), measurement, "other")) %>%
  group_by(accession_minus_prefix, type, set, species, measurement2, database) %>%
  summarize(pct2 = sum(pct))

cbeij_long_pct$database <- factor(cbeij_long_pct$database, levels = c('gtdb-rs202', 'p__Firmicutes_A', 'c__Clostridia', 'o__Clostridiales', 'f__Clostridiaceae', 'g__Clostridium', 's__Clostridium_beijerincki'))

lineage_plt <- ggplot(cbeij_long_pct, 
                      aes(x = database, y = pct2, label = round(pct2, digits = 2), fill = measurement2)) +
  geom_col() +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.text = element_text(size = 7),
        axis.title = element_text(size = 8),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 7),
        strip.text = element_text(size = 8),
        panel.spacing = unit(.1, "lines")) +
  geom_text(size = 2, position = position_stack(vjust = 0.5)) + 
  coord_flip() +
  labs(x = "species", y = "percent of reads", fill = "read type") +
  facet_wrap(~ type + set, scales = "free_y", 
             labeller = as_labeller(c(cds = "Coding", noncds = "Non-coding", 
                                      gtdb_representatives = "Genome in GTDB",
                                      refseq_not_in_gtdb = "Genome not in GTDB"))) +
  scale_fill_brewer(palette = "Dark2", labels = c("Coding", "Non-coding", "Other")) +
  guides(fill = guide_legend(nrow = 1))
lineage_plt
```

## thermo

```{r read_thermo}
thermo_gtdb <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/gtdb-rs202/protein-k10/GCA_018588215.1*json",
                                     database = "gtdb-rs202", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

thermo_phylum <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/p__Thermotogota/protein-k10/GCA_018588215.1*json",
                                     database = "p__Thermotogota", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

thermo_class <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/c__Thermotogae/protein-k10/GCA_018588215.1*json",
                                     database = "c__Thermotogae", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

thermo_order <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/o__Thermotogales/protein-k10/GCA_018588215.1*json",
                                     database = "o__Thermotogales", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

thermo_family <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/f__Fervidobacteriaceae/protein-k10/GCA_018588215.1*json",
                                     database = "f__Fervidobacteriaceae", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

thermo_genus <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/g__Thermosipho/protein-k10/GCA_018588215.1*json",
                                     database = "g__Thermosipho", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

thermo_species <- json <- read_and_format_orpheum_json(sys_glob_path = "outputs/orpheum/s__Thermosipho_affectus/protein-k10/GCA_018588215.1*json",
                                     database = "s__Thermosipho_affectus", 
                                     alphabet = "protein",
                                     ksize = 10)  %>%
  separate(sample, into = c("prefix", "accession_minus_prefix", "type"), sep = "_", remove = F) %>%
  mutate(accession_minus_prefix = gsub("\\..*", "", accession_minus_prefix)) %>%
  left_join(info, by = "accession_minus_prefix")

thermo <- bind_rows(thermo_species, thermo_genus, thermo_family, thermo_order,
                    thermo_class, thermo_phylum, thermo_gtdb)
```

```{r reformat_thermo}
thermo_long_pct <- thermo %>%
  select(accession_minus_prefix, type, set, database, total_reads,
         translation_is_shorter_than_peptide_k_mer_size_1, 
         translation_frame_has_stop_codon_s, coding, non_coding, low_complexity_nucleotide,
         read_length_was_shorter_than_3_peptide_k_mer_size, low_complexity_peptide_in_protein20_alphabet) %>%
  pivot_longer(cols = translation_is_shorter_than_peptide_k_mer_size_1:low_complexity_peptide_in_protein20_alphabet, names_to = "measurement", values_to = "reads") %>%
  mutate(pct = reads/total_reads * 100) 

thermo_long_pct <- thermo_long_pct %>%
   left_join(gtdbtk)
```

```{r}
# change category to "other" for measurements
thermo_long_pct <- thermo_long_pct %>%
  mutate(measurement2 = ifelse(measurement %in% c("coding", "non_coding"), measurement, "other")) %>%
  group_by(accession_minus_prefix, type, set, species, measurement2, database) %>%
  summarize(pct2 = sum(pct))

thermo_long_pct$database <- factor(thermo_long_pct$database, levels = c('gtdb-rs202', 'p__Thermotogota', 'c__Thermotogae', 'o__Thermotogales', 'f__Fervidobacteriaceae', 'g__Thermosipho', 's__Thermosipho_affectus'))

lineage_plt <- ggplot(thermo_long_pct, 
                      aes(x = database, y = pct2, label = round(pct2, digits = 2), fill = measurement2)) +
  geom_col() +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.text = element_text(size = 7),
        axis.title = element_text(size = 8),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 7),
        strip.text = element_text(size = 8),
        panel.spacing = unit(.1, "lines")) +
  geom_text(size = 2, position = position_stack(vjust = 0.5)) + 
  coord_flip() +
  labs(x = "species", y = "percent of reads", fill = "read type") +
  facet_wrap(~ type + set, scales = "free_y", 
             labeller = as_labeller(c(cds = "Coding", noncds = "Non-coding", 
                                      gtdb_representatives = "Genome in GTDB",
                                      refseq_not_in_gtdb = "Genome not in GTDB"))) +
  scale_fill_brewer(palette = "Dark2", labels = c("Coding", "Non-coding", "Other")) +
  guides(fill = guide_legend(nrow = 1))
lineage_plt
```


## combine plots


```{r}
pdf("orpheum_fig.pdf", height = 8, width = 6.5)
ggarrange(cds_noncds_gtdb_nongtdb_plt, 
          ggarrange(refseq_gtdbtk_plt, jaccard_tp_plt, 
                    labels = c("B", "C"), ncol = 2, widths = c(3, 4)),
          nrow = 2, labels = c("A", ""), heights = c(2, 1))
dev.off()
```

## Conclusion

Species adds the majority of predictive capacity, but the rest of GTDB seems necessary probably to fill out prediction of e.g. horizontally transferred elements. 
(The rest of GTDB thing isn't really demonstrated well here -- I know this from the *R. gnavus* experiments using just the family and genus level DBs. May be worth it here to demonstrate increasing recovery of coding reads with each level of inclusion of taxonomy up to phylum level. See if any of the species selected here in the `refseq not in gtdb` set can be used with DBs we already have...would have to be a ruminoccocus DB, if not maybe ask tessa to make a set of DBs.)